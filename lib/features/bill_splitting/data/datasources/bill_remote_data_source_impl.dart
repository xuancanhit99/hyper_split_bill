import 'package:hyper_split_bill/core/error/exceptions.dart';
import 'package:hyper_split_bill/features/bill_splitting/data/datasources/bill_remote_data_source.dart';
import 'package:hyper_split_bill/features/bill_splitting/data/models/bill_item_model.dart';
import 'package:hyper_split_bill/features/bill_splitting/data/models/bill_model.dart';
import 'package:hyper_split_bill/features/bill_splitting/data/models/participant_model.dart';
import 'package:injectable/injectable.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

@LazySingleton(as: BillRemoteDataSource) // Register with GetIt
class BillRemoteDataSourceImpl implements BillRemoteDataSource {
  final SupabaseClient _supabaseClient;

  BillRemoteDataSourceImpl(this._supabaseClient);

  // Helper to get current user ID, throws AuthServerException if not logged in
  String _getCurrentUserId() {
    final user = _supabaseClient.auth.currentUser;
    if (user == null) {
      throw const AuthServerException('User not authenticated.');
    }
    return user.id;
  }

  @override
  Future<BillModel> createBill(BillModel bill) async {
    final userId = _getCurrentUserId(); // Ensure user is authenticated
    try {
      // Prepare data for Supabase, ensuring user_id is set
      // and id is null so Supabase can generate it.
      final billDataToInsert = bill.toMap()
        ..['user_id'] = userId
        ..remove('id'); // Remove id if present, Supabase will generate it

      // Insert into 'bills' table and select the newly created row
      // .select() will return the inserted row including the generated ID
      final response = await _supabaseClient
          .from('bills')
          .insert(billDataToInsert)
          .select() // IMPORTANT: Select the inserted row to get the ID
          .single(); // Expect a single row to be returned

      // The response should contain the bill data including the 'id' generated by Supabase
      print("Supabase createBill response: $response");
      return BillModel.fromMap(response);
    } on PostgrestException catch (e) {
      print('Supabase PostgrestException during createBill: ${e.message}');
      print('Details: ${e.details}');
      print('Hint: ${e.hint}');
      throw ServerException('Failed to create bill: ${e.message}');
    } catch (e) {
      print('Unexpected error during createBill: $e');
      throw ServerException(
          'An unexpected error occurred while creating the bill: ${e.runtimeType}');
    }
  }

  @override
  Future<void> deleteBill(String billId) async {
    try {
      await _supabaseClient.from('bills').delete().match({
        'id': billId,
        'user_id': _getCurrentUserId()
      }); // Ensure user owns the bill
      // No return value needed, success means no exception
    } on PostgrestException catch (e) {
      throw ServerException('Failed to delete bill: ${e.message}');
    } catch (e) {
      throw ServerException(
          'An unexpected error occurred while deleting the bill: ${e.runtimeType}');
    }
  }

  @override
  Future<BillModel> getBillDetails(String billId) async {
    try {
      final response = await _supabaseClient.from('bills').select().match({
        'id': billId,
        'user_id': _getCurrentUserId()
      }) // Ensure user owns the bill
          .single(); // Expect one bill or PostgrestException

      return BillModel.fromMap(response);
    } on PostgrestException catch (e) {
      // Handle cases like bill not found (e.code == 'PGRST116') or other DB errors
      if (e.code == 'PGRST116') {
        // code for "JSON object requested, multiple (or no) rows returned"
        throw ServerException('Bill not found or access denied.');
      }
      throw ServerException('Failed to get bill details: ${e.message}');
    } catch (e) {
      throw ServerException(
          'An unexpected error occurred while fetching bill details: ${e.runtimeType}');
    }
  }

  @override
  Future<List<BillModel>> getBills() async {
    try {
      final response = await _supabaseClient
          .from('bills')
          .select()
          .eq('user_id', _getCurrentUserId()) // Filter by current user
          .order('created_at', ascending: false); // Order by creation date

      final bills = (response as List)
          .map(
              (billData) => BillModel.fromMap(billData as Map<String, dynamic>))
          .toList();
      return bills;
    } on PostgrestException catch (e) {
      throw ServerException('Failed to get bills: ${e.message}');
    } catch (e) {
      throw ServerException(
          'An unexpected error occurred while fetching bills: ${e.runtimeType}');
    }
  }

  @override
  Future<BillModel> updateBill(BillModel bill) async {
    try {
      // Ensure user_id is not accidentally updated if present in the map
      final billData = bill.toMap()
        ..remove('user_id')
        ..remove('id')
        ..remove('created_at');

      final response = await _supabaseClient
          .from('bills')
          .update(billData)
          .match({
            'id': bill.id,
            'user_id': _getCurrentUserId()
          }) // Ensure user owns the bill
          .select()
          .single();

      return BillModel.fromMap(response);
    } on PostgrestException catch (e) {
      if (e.code == 'PGRST116') {
        // No rows updated/returned
        throw ServerException('Bill not found or update failed.');
      }
      throw ServerException('Failed to update bill: ${e.message}');
    } catch (e) {
      throw ServerException(
          'An unexpected error occurred while updating the bill: ${e.runtimeType}');
    }
  }

  @override
  Future<List<BillItemModel>> saveBillItems(
      List<BillItemModel> items, String billId) async {
    if (items.isEmpty) return [];
    final userId = _getCurrentUserId(); // Lấy userId

    try {
      final itemsToInsert = items.map((item) {
        // Truyền cả billId và userId vào toMap
        // Tuy nhiên, bill_id sẽ được thêm vào map một cách riêng biệt bên dưới
        // để đảm bảo nó được đặt chính xác cho việc chèn.
        // Nếu toMap của bạn đã bao gồm bill_id, bạn có thể không cần dòng ..['bill_id'] = billId
        // Nhưng để an toàn và rõ ràng, chúng ta sẽ đặt nó một cách tường minh.
        final itemMap = item.toMap(
            billId: billId, userId: userId); // Truyền các tham số bắt buộc
        itemMap['bill_id'] = billId; // Đảm bảo bill_id được đặt cho việc chèn
        itemMap.remove('id'); // Xóa id nếu toMap bao gồm nó, để Supabase tạo
        // Nếu toMap không bao gồm user_id cho bảng bill_items, bạn có thể xóa nó khỏi map ở đây
        // itemMap.remove('user_id');
        return itemMap;
      }).toList();

      final response = await _supabaseClient
          .from('bill_items') // Assuming your table name for items
          .insert(itemsToInsert)
          .select(); // Select to get the inserted items with their new IDs

      print("Supabase saveBillItems response: $response");
      return (response as List)
          .map((itemData) =>
              BillItemModel.fromMap(itemData as Map<String, dynamic>))
          .toList();
    } on PostgrestException catch (e) {
      print('Supabase PostgrestException during saveBillItems: ${e.message}');
      throw ServerException('Failed to save bill items: ${e.message}');
    } catch (e) {
      print('Unexpected error during saveBillItems: $e');
      throw ServerException(
          'An unexpected error occurred while saving bill items: ${e.runtimeType}');
    }
  }

  @override
  Future<List<ParticipantModel>> saveParticipants(
      List<ParticipantModel> participants, String billId) async {
    if (participants.isEmpty) return [];
    final userId = _getCurrentUserId(); // Lấy userId

    try {
      final participantsToInsert = participants.map((p) {
        // Tương tự như với items
        final participantMap = p.toMap(
            billId: billId, userId: userId); // Truyền các tham số bắt buộc
        participantMap['bill_id'] = billId; // Đảm bảo bill_id
        participantMap.remove('id'); // Xóa id
        // participantMap.remove('user_id'); // Cân nhắc xóa nếu không cần trong bảng participants
        return participantMap;
      }).toList();

      final response = await _supabaseClient
          .from(
              'bill_participants') // Assuming your table name for participants
          .insert(participantsToInsert)
          .select();

      print("Supabase saveParticipants response: $response");
      return (response as List)
          .map((pData) =>
              ParticipantModel.fromMap(pData as Map<String, dynamic>))
          .toList();
    } on PostgrestException catch (e) {
      print(
          'Supabase PostgrestException during saveParticipants: ${e.message}');
      throw ServerException('Failed to save participants: ${e.message}');
    } catch (e) {
      print('Unexpected error during saveParticipants: $e');
      throw ServerException(
          'An unexpected error occurred while saving participants: ${e.runtimeType}');
    }
  }

  // TODO: Implement methods for assignments
}
