import 'package:hyper_split_bill/core/error/exceptions.dart';
import 'package:hyper_split_bill/features/bill_splitting/data/datasources/bill_remote_data_source.dart';
import 'package:hyper_split_bill/features/bill_splitting/data/models/bill_item_model.dart';
import 'package:hyper_split_bill/features/bill_splitting/data/models/bill_model.dart';
import 'package:hyper_split_bill/features/bill_splitting/data/models/participant_model.dart';
import 'package:hyper_split_bill/features/bill_splitting/domain/entities/bill_item_entity.dart';

import 'package:injectable/injectable.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

@LazySingleton(as: BillRemoteDataSource) // Register with GetIt
class BillRemoteDataSourceImpl implements BillRemoteDataSource {
  final SupabaseClient _supabaseClient;

  BillRemoteDataSourceImpl(this._supabaseClient);

  // Helper to get current user ID, throws AuthServerException if not logged in
  String _getCurrentUserId() {
    final user = _supabaseClient.auth.currentUser;
    if (user == null) {
      throw const AuthServerException('User not authenticated.');
    }
    return user.id;
  }

  @override
  Future<BillModel> createBill(BillModel bill) async {
    final userId = _getCurrentUserId(); // Ensure user is authenticated
    try {
      // Prepare data for Supabase, ensuring user_id is set
      // and id is null so Supabase can generate it.
      final billDataToInsert = bill.toMap()
        ..['user_id'] = userId
        ..remove('id'); // Remove id if present, Supabase will generate it

      // Insert into 'bills' table and select the newly created row
      // .select() will return the inserted row including the generated ID
      final response = await _supabaseClient
          .from('bills')
          .insert(billDataToInsert)
          .select() // IMPORTANT: Select the inserted row to get the ID
          .single(); // Expect a single row to be returned

      // The response should contain the bill data including the 'id' generated by Supabase
      print("Supabase createBill response: $response");
      return BillModel.fromMap(response);
    } on PostgrestException catch (e) {
      print('Supabase PostgrestException during createBill: ${e.message}');
      print('Details: ${e.details}');
      print('Hint: ${e.hint}');
      throw ServerException('Failed to create bill: ${e.message}');
    } catch (e) {
      print('Unexpected error during createBill: $e');
      throw ServerException(
          'An unexpected error occurred while creating the bill: ${e.runtimeType}');
    }
  }

  @override
  Future<void> deleteBill(String billId) async {
    try {
      await _supabaseClient.from('bills').delete().match({
        'id': billId,
        'user_id': _getCurrentUserId()
      }); // Ensure user owns the bill
      // No return value needed, success means no exception
    } on PostgrestException catch (e) {
      throw ServerException('Failed to delete bill: ${e.message}');
    } catch (e) {
      throw ServerException(
          'An unexpected error occurred while deleting the bill: ${e.runtimeType}');
    }
  }

  @override
  Future<BillModel> getBillDetails(String billId) async {
    try {
      final response = await _supabaseClient.from('bills').select().match({
        'id': billId,
        'user_id': _getCurrentUserId()
      }) // Ensure user owns the bill
          .single(); // Expect one bill or PostgrestException

      return BillModel.fromMap(response);
    } on PostgrestException catch (e) {
      // Handle cases like bill not found (e.code == 'PGRST116') or other DB errors
      if (e.code == 'PGRST116') {
        // code for "JSON object requested, multiple (or no) rows returned"
        throw ServerException('Bill not found or access denied.');
      }
      throw ServerException('Failed to get bill details: ${e.message}');
    } catch (e) {
      throw ServerException(
          'An unexpected error occurred while fetching bill details: ${e.runtimeType}');
    }
  }

  @override
  Future<List<BillModel>> getBills() async {
    try {
      final response = await _supabaseClient
          .from('bills')
          .select()
          .eq('user_id', _getCurrentUserId()) // Filter by current user
          .order('created_at', ascending: false); // Order by creation date

      final bills = (response as List)
          .map(
              (billData) => BillModel.fromMap(billData as Map<String, dynamic>))
          .toList();
      return bills;
    } on PostgrestException catch (e) {
      throw ServerException('Failed to get bills: ${e.message}');
    } catch (e) {
      throw ServerException(
          'An unexpected error occurred while fetching bills: ${e.runtimeType}');
    }
  }

  @override
  Future<BillModel> updateBill(BillModel bill) async {
    try {
      // Ensure user_id is not accidentally updated if present in the map
      final billData = bill.toMap()
        ..remove('user_id')
        ..remove('id')
        ..remove('created_at');

      final response = await _supabaseClient
          .from('bills')
          .update(billData)
          .match({
            'id': bill.id,
            'user_id': _getCurrentUserId()
          }) // Ensure user owns the bill
          .select()
          .single();

      return BillModel.fromMap(response);
    } on PostgrestException catch (e) {
      if (e.code == 'PGRST116') {
        // No rows updated/returned
        throw ServerException('Bill not found or update failed.');
      }
      throw ServerException('Failed to update bill: ${e.message}');
    } catch (e) {
      throw ServerException(
          'An unexpected error occurred while updating the bill: ${e.runtimeType}');
    }
  }

  @override
  Future<List<BillItemModel>> saveBillItems(
      List<BillItemModel> items, String billId) async {
    if (items.isEmpty) return [];
    // final userId = _getCurrentUserId(); // Xóa dòng này, không cần userId nữa

    try {
      final itemsToInsert = items.map((item) {
        // final itemMap = item.toMap(billId: billId, userId: userId); // Dòng cũ
        final itemMap =
            item.toMap(billId: billId); // Dòng mới: chỉ truyền billId
        itemMap['bill_id'] =
            billId; // Đảm bảo bill_id được đặt cho việc chèn (toMap đã làm điều này, nhưng để chắc chắn)
        itemMap.remove('id'); // Xóa id nếu toMap bao gồm nó, để Supabase tạo
        // itemMap.remove('user_id'); // Xóa dòng này, toMap không còn trả về user_id
        return itemMap;
      }).toList();

      final response = await _supabaseClient
          .from('bill_items') // Assuming your table name for items
          .insert(itemsToInsert)
          .select(); // Select to get the inserted items with their new IDs

      print("Supabase saveBillItems response: $response");
      return (response as List)
          .map((itemData) =>
              BillItemModel.fromMap(itemData as Map<String, dynamic>))
          .toList();
    } on PostgrestException catch (e) {
      print('Supabase PostgrestException during saveBillItems: ${e.message}');
      throw ServerException('Failed to save bill items: ${e.message}');
    } catch (e) {
      print('Unexpected error during saveBillItems: $e');
      throw ServerException(
          'An unexpected error occurred while saving bill items: ${e.runtimeType}');
    }
  }

  @override
  Future<List<ParticipantModel>> saveParticipants(
      List<ParticipantModel> participants, String billId) async {
    if (participants.isEmpty) return [];

    try {
      final participantsToInsert = participants.map((p) {
        // final participantMap = p.toMap(billId: billId, userId: userId); // Dòng cũ
        final participantMap =
            p.toMap(billId: billId); // Dòng mới: chỉ truyền billId
        participantMap['bill_id'] = billId; // Đảm bảo bill_id (toMap đã làm)
        participantMap.remove('id'); // Xóa id
        // participantMap.remove('user_id'); // Xóa dòng này
        return participantMap;
      }).toList();

      final response = await _supabaseClient
          .from(
              'bill_participants') // Assuming your table name for participants
          .insert(participantsToInsert)
          .select();

      print("Supabase saveParticipants response: $response");
      return (response as List)
          .map((pData) =>
              ParticipantModel.fromMap(pData as Map<String, dynamic>))
          .toList();
    } on PostgrestException catch (e) {
      print(
          'Supabase PostgrestException during saveParticipants: ${e.message}');
      throw ServerException('Failed to save participants: ${e.message}');
    } catch (e) {
      print('Unexpected error during saveParticipants: $e');
      throw ServerException(
          'An unexpected error occurred while saving participants: ${e.runtimeType}');
    }
  }
  @override
  Future<void> deleteBillItems(String billId) async {
    try {
      await _supabaseClient.from('bill_items').delete().eq('bill_id', billId);
      print("Deleted bill items for bill ID: $billId");
    } on PostgrestException catch (e) {
      print('Supabase PostgrestException during deleteBillItems: ${e.message}');
      throw ServerException('Failed to delete bill items: ${e.message}');
    } catch (e) {
      print('Unexpected error during deleteBillItems: $e');
      throw ServerException(
          'An unexpected error occurred while deleting bill items: ${e.runtimeType}');
    }
  }
  @override
  Future<void> deleteParticipants(String billId) async {
    try {
      await _supabaseClient.from('bill_participants').delete().eq('bill_id', billId);
      print("Deleted participants for bill ID: $billId");
    } on PostgrestException catch (e) {
      print('Supabase PostgrestException during deleteParticipants: ${e.message}');
      throw ServerException('Failed to delete participants: ${e.message}');
    } catch (e) {
      print('Unexpected error during deleteParticipants: $e');
      throw ServerException(
          'An unexpected error occurred while deleting participants: ${e.runtimeType}');
    }
  }  @override
  Future<void> deleteItemAssignments(String billId) async {
    try {
      print("Beginning deletion of item assignments for bill ID: $billId");
      
      // Item assignments are linked to bill items, which are linked to the bill
      // We need to first get all item IDs associated with this bill
      final itemsResponse = await _supabaseClient
          .from('bill_items')
          .select('id')
          .eq('bill_id', billId);
            if (itemsResponse.isNotEmpty) {
        // Extract item IDs
        final List<String> itemIds = [];
        for (var item in itemsResponse) {
          if (item['id'] != null) {
            itemIds.add(item['id'] as String);
          }
        }
        
        print("Found ${itemIds.length} bill items for bill ID: $billId");
        
        if (itemIds.isNotEmpty) {
          // Delete assignments for these items using filter for large ID lists
          // Use batches if there are many items
          const int batchSize = 100; // Supabase may have limits on array size
          
          for (int i = 0; i < itemIds.length; i += batchSize) {
            final end = (i + batchSize < itemIds.length) ? i + batchSize : itemIds.length;
            final batchIds = itemIds.sublist(i, end);
            
            await _supabaseClient
                .from('bill_item_assignments')
                .delete()
                .filter('bill_item_id', 'in', batchIds);
                
            print("Deleted item assignments for batch ${i ~/ batchSize + 1}");
          }
          
          print("Successfully deleted all item assignments for bill ID: $billId");
        } else {
          print("No valid item IDs found for bill ID: $billId");
        }
      } else {
        print("No items found for bill ID: $billId, no assignments to delete");
      }
    } on PostgrestException catch (e) {
      print('Supabase PostgrestException during deleteItemAssignments: ${e.message}');
      print('Details: ${e.details}');
      throw ServerException('Failed to delete item assignments: ${e.message}');
    } catch (e) {
      print('Unexpected error during deleteItemAssignments: $e');
      throw ServerException(
          'An unexpected error occurred while deleting item assignments: ${e.runtimeType}');
    }
  }  @override
  Future<void> saveItemAssignments(List<BillItemEntity> items) async {
    if (items.isEmpty) return;
    
    try {
      // Get the bill ID from the first item
      final firstItem = items.firstWhere((item) => item.id != null && item.id!.isNotEmpty);
      final firstItemId = firstItem.id;
      if (firstItemId == null || firstItemId.isEmpty) return;
      
      // Query to get the bill_id from the first item
      final itemData = await _supabaseClient
          .from('bill_items')
          .select('bill_id')
          .eq('id', firstItemId)
          .single();
      
      final billId = itemData['bill_id'] as String;
      
      // Get all participants for this bill to create the mapping
      final participantsResponse = await _supabaseClient
          .from('bill_participants')
          .select('id, name')
          .eq('bill_id', billId);
      
      if (participantsResponse.isEmpty) {
        print('No participants found for bill ID: $billId');
        return;
      }
      
      // Build a map of participant names to database UUIDs
      final Map<String, String> participantNameToDbIdMap = {};
      for (final participant in participantsResponse) {
        final name = participant['name'] as String;
        final dbId = participant['id'] as String;
        participantNameToDbIdMap[name] = dbId;
      }
      
      print('Participant name to DB ID mapping: $participantNameToDbIdMap');
      
      List<Map<String, dynamic>> assignmentsToInsert = [];
      
      // Process each item and create assignments
      for (final item in items) {
        final itemId = item.id;
        if (itemId == null || itemId.isEmpty) continue;
        
        // Process participants with weights if available
        if (item.participants.isNotEmpty) {
          for (final participant in item.participants) {
            final clientParticipantId = participant.participantId;
            if (clientParticipantId.isEmpty) continue;
            
            // Find the database UUID by matching participant names
            // The client participant ID might be a client-generated ID, but we need to map it to the actual participant
            String? databaseId;
            
            // Try to find the participant by looking through the database participants
            // Since we don't have a direct mapping from client ID to DB ID, 
            // we need to use the fact that the participant order should be preserved
            // or find another way to match them.
            
            // For now, let's try to match by name if the participantId looks like a client-generated ID
            if (clientParticipantId.startsWith('p_')) {
              // This is a client-generated ID, we need to find the corresponding participant by other means
              // For bills from history, we need to look at the bill structure to map properly
              
              // Let's try a different approach: match by index in the participants list
              // This assumes the order is preserved between client and database
              final participantIndex = item.participants.indexOf(participant);
              if (participantIndex < participantsResponse.length) {
                databaseId = participantsResponse[participantIndex]['id'] as String;
                print('Mapped client participant ID $clientParticipantId at index $participantIndex to database ID: $databaseId');
              }
            } else {
              // If it's not a client-generated ID, try to find by name
              databaseId = participantNameToDbIdMap[clientParticipantId];
            }
            
            if (databaseId != null) {
              assignmentsToInsert.add({
                'bill_item_id': itemId,
                'participant_id': databaseId,
                'weight': participant.weight.toDouble(),
              });
              print('Added assignment: item $itemId -> participant $databaseId (weight: ${participant.weight})');
            } else {
              print('Warning: Could not map client participant ID $clientParticipantId to database ID');
            }
          }
        }
        // Fall back to participantIds for backward compatibility
        else if (item.participantIds.isNotEmpty) {
          for (final clientParticipantId in item.participantIds) {
            if (clientParticipantId.isEmpty) continue;
            
            String? databaseId;
            
            if (clientParticipantId.startsWith('p_')) {
              // Client-generated ID, match by index
              final participantIndex = item.participantIds.indexOf(clientParticipantId);
              if (participantIndex < participantsResponse.length) {
                databaseId = participantsResponse[participantIndex]['id'] as String;
              }
            } else {
              // Try to match by name
              databaseId = participantNameToDbIdMap[clientParticipantId];
            }
            
            if (databaseId != null) {
              assignmentsToInsert.add({
                'bill_item_id': itemId,
                'participant_id': databaseId,
                'weight': 1.0, // Default weight
              });
            }
          }
        }
      }
      
      if (assignmentsToInsert.isEmpty) {
        print('No valid assignments to insert after mapping');
        return;
      }
      
      // Insert the assignments
      print("Inserting ${assignmentsToInsert.length} item assignments");
      final response = await _supabaseClient
        .from('bill_item_assignments')
        .insert(assignmentsToInsert)
        .select();
          print("Successfully saved ${(response as List).length} item assignments");
    } on PostgrestException catch (e) {
      print('Supabase PostgrestException during saveItemAssignments: ${e.message}');
      print('Details: ${e.details}');
      throw ServerException('Failed to save item assignments: ${e.message}');
    } catch (e) {
      print('Unexpected error during saveItemAssignments: $e');
      throw ServerException(
          'An unexpected error occurred while saving item assignments: ${e.runtimeType}');
    }
  }
}
